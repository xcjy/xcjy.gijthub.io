<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="基本语法标志符大小写敏感 命名规则： 1.第一个字符是$  _ 字母（英语和其他语言字母）    2.其余字符 除了上面三种还可以用数字 变量提升所有被声明的代码，都会被提升到代码的头部 12345678console.log(a);var a = 1;上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习">
<meta property="og:url" content="http://yoursite.com/2019/03/24/JavaScript学习/index.html">
<meta property="og:site_name" content="cjy">
<meta property="og:description" content="基本语法标志符大小写敏感 命名规则： 1.第一个字符是$  _ 字母（英语和其他语言字母）    2.其余字符 除了上面三种还可以用数字 变量提升所有被声明的代码，都会被提升到代码的头部 12345678console.log(a);var a = 1;上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-30T15:32:22.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript学习">
<meta name="twitter:description" content="基本语法标志符大小写敏感 命名规则： 1.第一个字符是$  _ 字母（英语和其他语言字母）    2.其余字符 除了上面三种还可以用数字 变量提升所有被声明的代码，都会被提升到代码的头部 12345678console.log(a);var a = 1;上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/24/JavaScript学习/">





  <title>JavaScript学习 | cjy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cjy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/JavaScript学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cjy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cjy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-24T20:26:50+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><p>大小写敏感</p>
<p>命名规则：</p>
<p>1.第一个字符是$  _ 字母（英语和其他语言字母）   </p>
<p>2.其余字符 除了上面三种还可以用数字</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>所有被声明的代码，都会被提升到代码的头部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a = 1;</span><br><span class="line">上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 1;</span><br><span class="line">最后的结果是显示undefined，表示变量a已声明，但还未赋值。</span><br></pre></td></tr></table></figure>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>switch       用的是===  而不是== 所以不会发生类型转换</p>
<h2 id="标签-label"><a href="#标签-label" class="headerlink" title="标签(label)"></a>标签(label)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">         语句</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) break top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// i=0, j=0</span><br><span class="line">// i=0, j=1</span><br><span class="line">// i=0, j=2</span><br><span class="line">// i=1, j=0</span><br></pre></td></tr></table></figure>
<p>可以跳出双重循环，不加只能跳出内层循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i = 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i === 1 &amp;&amp; j === 1) continue top;</span><br><span class="line">      console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  continue则进入下一层外层循坏</span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>6种数据类型,ES6又增加了一种Symbol</p>
<p>数值(number)：整数和小数   NaN</p>
<p>字符串(string):  文本</p>
<p>布尔值(boolean)</p>
<p>undefined:</p>
<p>null:</p>
<p>object</p>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（object）</li>
<li><p>数组（array）</p>
</li>
<li><p>函数（function）    </p>
</li>
</ul>
<h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><code>typeof</code>运算符</li>
<li><code>instanceof</code>运算符 （可区分数组与对象  a instanceof Array）</li>
<li><code>Object.prototype.toString</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误的写法</span><br><span class="line">if (v) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">// 正确的写法</span><br><span class="line">if (typeof v === &quot;undefined&quot;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof null // &quot;object&quot;</span><br><span class="line">历史原因~ 第一版只有5种数据类型</span><br></pre></td></tr></table></figure>
<h2 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null undefined 和布尔值"></a>null undefined 和布尔值</h2><p>两者if语句都为false</p>
<p>Number(null)  //0</p>
<p>Number(undefined)  //NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i // undefined</span><br><span class="line"></span><br><span class="line">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="line">function f(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">f() // undefined</span><br><span class="line"></span><br><span class="line">// 对象没有赋值的属性</span><br><span class="line">var  o = new Object();</span><br><span class="line">o.p // undefined</span><br><span class="line"></span><br><span class="line">// 函数没有返回值时，默认返回 undefined</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">f() // undefined</span><br></pre></td></tr></table></figure>
<p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3</span><br><span class="line">// false</span><br><span class="line"></span><br><span class="line">0.3 / 0.1</span><br><span class="line">// 2.9999999999999996</span><br><span class="line"></span><br><span class="line">(0.3 - 0.2) === (0.2 - 0.1)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>
<h2 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h2><p>一个数在 JavaScript 内部实际的表示形式。</p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2^53到2^53，都可以精确表示。</p>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h2><p><code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p>
<p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: function (x) &#123;</span><br><span class="line">    return 2 * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(1) // 2</span><br></pre></td></tr></table></figure>
<p><strong>属性可以动态创建，不必在对象声明时就指定。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.foo = 123;</span><br><span class="line">obj.foo // 123</span><br></pre></td></tr></table></figure>
<p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><h3 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h3><p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person // true</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor === Person // false</span><br><span class="line">Person.prototype.constructor === Object // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向。</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">v instanceof Vehicle // true</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v instanceof Vehicle</span><br><span class="line">// 等同于</span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = [1, 2, 3];</span><br><span class="line">var y = &#123;&#125;;</span><br><span class="line">x instanceof Array // true</span><br><span class="line">y instanceof Object // true</span><br></pre></td></tr></table></figure>
<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>
<h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Sub(value) &#123;</span><br><span class="line">  Super.call(this);</span><br><span class="line">  this.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性。</p>
<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = Object.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = &apos;...&apos;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p>function Shape() {</p>
<p>​    this.x = 0;</p>
<p>​    this.y = 0;</p>
<p>  }</p>
<p>  Shape.prototype.move = function (x, y) {</p>
<p>​    this.x += x;</p>
<p>​    this.y += y;</p>
<p>​    console.info(‘Shape moved.’);</p>
<p>  };</p>
<p>function Rectangle(){  </p>
<p>​    Shape.call(this);</p>
<p>}</p>
<p>Rectangle.prototype=Object.create(Shape.prototype);</p>
<p>Rectangle.prototype.constructor=Rectangle;</p>
<p>var rect=new Rectangle();</p>
<p>console.log(  rect instanceof Rectangle);</p>
<p>console.log( rect instanceof Shape);</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function M1() &#123;</span><br><span class="line">  this.hello = &apos;hello&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function M2() &#123;</span><br><span class="line">  this.world = &apos;world&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function S() &#123;</span><br><span class="line">  M1.call(this);</span><br><span class="line">  M2.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承 M1</span><br><span class="line">S.prototype = Object.create(M1.prototype);</span><br><span class="line">// 继承链上加入 M2</span><br><span class="line">Object.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line">// 指定构造函数</span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line">var s = new S();</span><br><span class="line">s.hello // &apos;hello&apos;</span><br><span class="line">s.world // &apos;world&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h5 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h5><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<p>var module1=(function(){</p>
<p>   var _count=0;</p>
<p>   var m1=function(){</p>
<p>​       </p>
<p>   };</p>
<p>   var m2=function(){</p>
<p>   };</p>
<p>   return {</p>
<p>​    m1 :m1,</p>
<p>​    m2 :m2</p>
<p>   };</p>
<p>})();</p>
<h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (function (mod)&#123;</span><br><span class="line">　mod.m3 = function () &#123;</span><br><span class="line">　　//...</span><br><span class="line">　&#125;;</span><br><span class="line">　return mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>
<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (function (mod) &#123;</span><br><span class="line">　//...</span><br><span class="line">　return mod;</span><br><span class="line">&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h3 id="Object对象的相关方法"><a href="#Object对象的相关方法" class="headerlink" title="Object对象的相关方法"></a>Object对象的相关方法</h3><h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>返回参数对象的原型</p>
<p>下面是几种特殊对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 空对象的原型是 Object.prototype</span><br><span class="line">Object.getPrototypeOf(&#123;&#125;) === Object.prototype // true</span><br><span class="line"></span><br><span class="line">// Object.prototype 的原型是 null</span><br><span class="line">Object.getPrototypeOf(Object.prototype) === null // true</span><br><span class="line"></span><br><span class="line">// 函数的原型是 Function.prototype</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">Object.getPrototypeOf(f) === Function.prototype // true</span><br></pre></td></tr></table></figure>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<p><code>new</code>命令可以使用<code>Object.setPrototypeOf</code>方法模拟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var F = function () &#123;</span><br><span class="line">  this.foo = &apos;bar&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var f = new F();</span><br><span class="line">// 等同于</span><br><span class="line">var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);</span><br><span class="line">F.call(f);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>能从一个实例对象，生成另一个实例对象呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 原型对象</span><br><span class="line">var A = &#123;</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    console.log(&apos;hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 实例对象</span><br><span class="line">var B = Object.create(A);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(B) === A // true</span><br><span class="line">B.print() // hello</span><br><span class="line">B.print === A.print // true</span><br></pre></td></tr></table></figure>
<p><strong>下面三种方式生成的新对象是等价的。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = Object.create(&#123;&#125;);</span><br><span class="line">var obj2 = Object.create(Object.prototype);</span><br><span class="line">var obj3 = new Object();</span><br></pre></td></tr></table></figure>
<p>如果想要生成一个不继承任何属性（比如没有<code>toString</code>和<code>valueOf</code>方法）的对象，可以将<code>Object.create</code>的参数设为<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(null);</span><br><span class="line"></span><br><span class="line">obj.valueOf()</span><br><span class="line">// TypeError: Object [object Object] has no method &apos;valueOf&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf</code>方法。</p>
<p>使用<code>Object.create</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.create()</span><br><span class="line">// TypeError: Object prototype may only be an Object or null</span><br><span class="line">Object.create(123)</span><br><span class="line">// TypeError: Object prototype may only be an Object or null</span><br></pre></td></tr></table></figure>
<h4 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h4><p>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = Object.create(o1);</span><br><span class="line">var o3 = Object.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) // true</span><br><span class="line">o1.isPrototypeOf(o3) // trueO</span><br></pre></td></tr></table></figure>
<h4 id="object-prototype-proto"><a href="#object-prototype-proto" class="headerlink" title="object.prototype.proto"></a>object.prototype.<strong>proto</strong></h4><p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p>
<h4 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h4><p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<h4 id="Object-getOwnPropertyName"><a href="#Object-getOwnPropertyName" class="headerlink" title="Object.getOwnPropertyName()"></a>Object.getOwnPropertyName()</h4><p><code></code>Object.getOwnPropertyNames`方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(Date)</span><br><span class="line">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Date) // []</span><br></pre></td></tr></table></figure>
<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h4 id="Object-prototpye-hasOwnProperty"><a href="#Object-prototpye-hasOwnProperty" class="headerlink" title="Object.prototpye.hasOwnProperty"></a>Object.prototpye.hasOwnProperty</h4><p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h4 id="in-与-for-in"><a href="#in-与-for-in" class="headerlink" title="in 与 for ..in"></a>in 与 for ..in</h4><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;length&apos; in Date // true</span><br><span class="line">&apos;toString&apos; in Date // true</span><br></pre></td></tr></table></figure>
<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123; p1: 123 &#125;;</span><br><span class="line"></span><br><span class="line">var o2 = Object.create(o1, &#123;</span><br><span class="line">  p2: &#123; value: &quot;abc&quot;, enumerable: true &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for (p in o2) &#123;</span><br><span class="line">  console.info(p);</span><br><span class="line">&#125;</span><br><span class="line">// p2</span><br><span class="line">// p1</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历。</p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ( var name in object ) &#123;</span><br><span class="line">  if ( object.hasOwnProperty(name) ) &#123;</span><br><span class="line">    /* loop code */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h4><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h4 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h4><p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure>
<p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p>
<p>严格模式可以用于整个脚本，也可以只用于单个函数。</p>
<p><strong>（1） 整个脚本文件</strong></p>
<p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  console.log(&apos;这是严格模式&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&apos;这是正常模式&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2）单个函数</strong></p>
<p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function strict() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  return &apos;这是严格模式&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function strict2() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return &apos;这也是严格模式&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function notStrict() &#123;</span><br><span class="line">  return &apos;这是正常模式&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示报错"><a href="#显示报错" class="headerlink" title="显示报错"></a>显示报错</h4><h5 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h5><p>严格模式下，设置字符串的<code>length</code>属性，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">&apos;abc&apos;.length = 5;</span><br><span class="line">// TypeError: Cannot assign to read only property &apos;length&apos; of string &apos;abc&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错。</p>
<p><strong>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</strong></p>
<h5 id="严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。"><a href="#严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。" class="headerlink" title="严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。"></a>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  get v() &#123; return 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.v = 2;</span><br><span class="line">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span><br></pre></td></tr></table></figure>
<h5 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h5><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">obj.v = 1;</span><br><span class="line">// Uncaught TypeError: Cannot add property v, object is not extensible</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错。</p>
<h5 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h5><h5 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h5><h5 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h5><h3 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h3><p><strong>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</strong></p>
<p> <strong>禁止 this 关键字指向全局对象</strong></p>
<p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 正常模式</span><br><span class="line">function fun() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() // window</span><br><span class="line">fun.call(2) // Number &#123;2&#125;</span><br><span class="line">fun.call(true) // Boolean &#123;true&#125;</span><br><span class="line">fun.call(null) // window</span><br><span class="line">fun.call(undefined) // window</span><br><span class="line"></span><br><span class="line">// 严格模式</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">function fun() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() //undefined</span><br><span class="line">fun.call(2) // 2</span><br><span class="line">fun.call(true) // true</span><br><span class="line">fun.call(null) // null</span><br><span class="line">fun.call(undefined) // undefined</span><br></pre></td></tr></table></figure>
<p><strong>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</strong></p>
<p><strong>禁止使用 arguments.callee、arguments.calle</strong></p>
<p><strong>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var x;</span><br><span class="line">delete x; // 语法错误</span><br><span class="line"></span><br><span class="line">var obj = Object.create(null, &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">delete obj.x; // 删除成功</span><br></pre></td></tr></table></figure>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>
<p><strong>1.严格模式下，禁止使用with  因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</strong></p>
<p><strong>2.eval作用域</strong></p>
<p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</p>
<p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  var x = 2;</span><br><span class="line">  console.log(eval(&apos;var x = 5; x&apos;)) // 5</span><br><span class="line">  console.log(x) // 2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部。</p>
<p>  <strong>3.arguments不在追踪参数变化</strong></p>
<p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  a = 2;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">f(1); // 正常模式为[2, 2]</span><br><span class="line"></span><br><span class="line">function f(a) &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  a = 2;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">f(1); // 严格模式为[2, 1]</span><br></pre></td></tr></table></figure>
<p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p>
<h3 id="向ES6过渡"><a href="#向ES6过渡" class="headerlink" title="向ES6过渡"></a>向ES6过渡</h3><p>为了平稳过渡，严格模式引入了一些 ES6 语法。</p>
<h4 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h4><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  function f1() &#123; &#125; // 语法错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  function f2() &#123; &#125; // 语法错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错。</p>
<p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。</p>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function package(protected) &#123; // 语法错误</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  var implements; // 语法错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>
<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<h4 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h4><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href="http://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件</p>
<h4 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h4><h5 id="4-1回调函数"><a href="#4-1回调函数" class="headerlink" title="4.1回调函数"></a>4.1回调函数</h5><p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1(callback) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>
<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href="http://en.wikipedia.org/wiki/Coupling_(computer_programming" target="_blank" rel="noopener">耦合</a>)（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h5 id="4-2事件监听"><a href="#4-2事件监听" class="headerlink" title="4.2事件监听"></a>4.2事件监听</h5><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href="http://api.jquery.com/on/" target="_blank" rel="noopener">写法</a>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&apos;done&apos;, f2);</span><br></pre></td></tr></table></figure>
<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">    f1.trigger(&apos;done&apos;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href="http://en.wikipedia.org/wiki/Decoupling" target="_blank" rel="noopener">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h5 id="4-3-发布-订阅"><a href="#4-3-发布-订阅" class="headerlink" title="4.3 发布/订阅"></a>4.3 发布/订阅</h5><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="http://en.wikipedia.org/wiki/Publish-subscribe_pattern" target="_blank" rel="noopener">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noopener">观察者模式</a>”（observer pattern）。</p>
<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="5-异步操作的流程控制"><a href="#5-异步操作的流程控制" class="headerlink" title="5.异步操作的流程控制"></a>5.异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>首先，Promise 是一个对象，也是一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1(resolve, reject) &#123;</span><br><span class="line">  // 异步代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Promise(f1);</span><br></pre></td></tr></table></figure>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<h4 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a>Promise对象的状态</h4><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p>
<p><strong>这三种的状态的变化途径只有两种。</strong></p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p><strong>因此，Promise 的最终结果只有两种。</strong></p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>
</ul>
<h4 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h4><p>JavaScript 提供原生的<code>Promise</code>构造函数，用来生成 Promise 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123; /* 异步操作失败 */</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><p>Promise 实例的<code>then</code>方法，用来添加回调函数。</p>
<p>Promise 的用法，简单说就是一句话：使用<code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">f1().then(function () &#123;</span><br><span class="line">  return f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">f1().then(function () &#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">f1().then(f2());</span><br><span class="line"></span><br><span class="line">// 写法四</span><br><span class="line">f1().then(f2);</span><br></pre></td></tr></table></figure>
<p>为了便于讲解，下面这四种写法都再用<code>then</code>方法接一个回调函数<code>f3</code>。写法一的<code>f3</code>回调函数的参数，是<code>f2</code>函数的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1().then(function () &#123;</span><br><span class="line">  return f2();</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>
<p>写法二的<code>f3</code>回调函数的参数是<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1().then(function () &#123;</span><br><span class="line">  f2();</span><br><span class="line">  return;</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>
<p>写法三的<code>f3</code>回调函数的参数，是<code>f2</code>函数返回的函数的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().then(f2())</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>
<p>写法四与写法一只有一个差别，那就是<code>f2</code>会接收到<code>f1()</code>返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().then(f2)</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>节点的类型有七种。</p>
<ul>
<li><code>Document</code>：整个文档树的顶层节点</li>
<li><code>DocumentType</code>：<code>doctype</code>标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li>
<li><code>Element</code>：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li>
<li><code>Attribute</code>：网页元素的属性（比如<code>class=&quot;right&quot;</code>）</li>
<li><code>Text</code>：标签之间或标签包含的文本</li>
<li><code>Comment</code>：注释</li>
<li><code>DocumentFragment</code>：文档的片段</li>
</ul>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">// 整个文档树</span><br></pre></td></tr></table></figure>
<p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<h2 id="Node接口"><a href="#Node接口" class="headerlink" title="Node接口"></a>Node接口</h2><h3 id="1-1-Node-prototype-nodeType"><a href="#1-1-Node-prototype-nodeType" class="headerlink" title="1.1 Node.prototype.nodeType"></a>1.1 Node.prototype.nodeType</h3><p><code>nodeType</code>属性返回一个整数值，表示节点的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType // 9</span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.nodeType === Node.DOCUMENT_NODE // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的<code>nodeType</code>属性等于常量<code>Node.DOCUMENT_NODE</code>。</p>
<p>不同节点的<code>nodeType</code>属性值和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li>
</ul>
<p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var node = document.documentElement.firstChild;</span><br><span class="line">if (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">  console.log(&apos;该节点是元素节点&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Node-prototype-nodeName"><a href="#1-2-Node-prototype-nodeName" class="headerlink" title="1.2 Node.prototype.nodeName"></a>1.2 Node.prototype.nodeName</h3><p><code>nodeName</code>属性返回节点的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span><br><span class="line">var div = document.getElementById(&apos;d1&apos;);</span><br><span class="line">div.nodeName // &quot;DIV&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，元素节点<code>&lt;div&gt;</code>的<code>nodeName</code>属性就是大写的标签名<code>DIV</code>。</p>
<p>不同节点的<code>nodeName</code>属性值如下。</p>
<ul>
<li>文档节点（document）：<code>#document</code></li>
<li>元素节点（element）：大写的标签名</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：<code>#text</code></li>
<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：<code>#comment</code></li>
</ul>
<h3 id="1-3Node-prototype-nodeValue"><a href="#1-3Node-prototype-nodeValue" class="headerlink" title="1.3Node.prototype.nodeValue"></a>1.3Node.prototype.nodeValue</h3><p><code>nodeValue</code>属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>
<p>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code>。同样的，也只有这三类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello world&lt;/div&gt;</span><br><span class="line">var div = document.getElementById(&apos;d1&apos;);</span><br><span class="line">div.nodeValue // null</span><br><span class="line">div.firstChild.nodeValue // &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>是元素节点，<code>nodeValue</code>属性返回<code>null</code>。<code>div.firstChild</code>是文本节点，所以可以返回文本值。</p>
<h3 id="1-4-Node-prototype-textContent"><a href="#1-4-Node-prototype-textContent" class="headerlink" title="1.4 Node.prototype.textContent"></a>1.4 Node.prototype.textContent</h3><p><code>textContent</code>属性返回当前节点和它的所有后代节点的文本内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码为</span><br><span class="line">// &lt;div id=&quot;divA&quot;&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;divA&apos;).textContent</span><br><span class="line">// This is some text</span><br></pre></td></tr></table></figure>
<p><code>textContent</code>属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。</p>
<h3 id="1-5-Node-prototype-baseURI"><a href="#1-5-Node-prototype-baseURI" class="headerlink" title="1.5 Node.prototype.baseURI"></a>1.5 Node.prototype.baseURI</h3><p><code>baseURI</code>属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前网页的网址为</span><br><span class="line">// http://www.example.com/index.html</span><br><span class="line">document.baseURI</span><br><span class="line">// &quot;http://www.example.com/index.html&quot;</span><br></pre></td></tr></table></figure>
<p>如果无法读到网页的 URL，<code>baseURI</code>属性返回<code>null</code>。</p>
<p>该属性的值一般由当前网址的 URL（即<code>window.location</code>属性）决定，但是可以使用 HTML 的<code>&lt;base&gt;</code>标签，改变该属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=&quot;http://www.example.com/page.html&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>设置了以后，<code>baseURI</code>属性就返回<code>&lt;base&gt;</code>标签设置的值。</p>
<h3 id="1-6-Node-prototype-ownerDocument"><a href="#1-6-Node-prototype-ownerDocument" class="headerlink" title="1.6 Node.prototype.ownerDocument"></a>1.6 Node.prototype.ownerDocument</h3><p><code>Node.ownerDocument</code>属性返回当前节点所在的顶层文档对象，即<code>document</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = p.ownerDocument;</span><br><span class="line">d === document // true</span><br></pre></td></tr></table></figure>
<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>
<h3 id="1-7-Node-prototype-nextSibling"><a href="#1-7-Node-prototype-nextSibling" class="headerlink" title="1.7 Node.prototype.nextSibling"></a>1.7 Node.prototype.nextSibling</h3><p><code>Node.nextSibling</code>属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回<code>null</code>。</p>
<p><code>nextSibling</code>属性可以用来遍历所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;div1&apos;).firstChild;</span><br><span class="line"></span><br><span class="line">while (el !== null) &#123;</span><br><span class="line">  console.log(el.nodeName);</span><br><span class="line">  el = el.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>div1</code>节点的所有子节点。</p>
<h3 id="1-8-Node-prototype-previousSibling"><a href="#1-8-Node-prototype-previousSibling" class="headerlink" title="1.8 Node.prototype.previousSibling"></a>1.8 Node.prototype.previousSibling</h3><p><code>previousSibling</code>属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;div id=&quot;d1&quot;&gt;hello&lt;/div&gt;&lt;div id=&quot;d2&quot;&gt;world&lt;/div&gt;</span><br><span class="line">var d1 = document.getElementById(&apos;d1&apos;);</span><br><span class="line">var d2 = document.getElementById(&apos;d2&apos;);</span><br><span class="line"></span><br><span class="line">d2.previousSibling === d1 // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>
<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h3 id="1-9-Node-prototype-parentNode"><a href="#1-9-Node-prototype-parentNode" class="headerlink" title="1.9 Node.prototype.parentNode"></a>1.9 Node.prototype.parentNode</h3><p><code>parentNode</code>属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面移除。</p>
<p>文档节点（document）和文档片段节点（documentfragment）的父节点都是<code>null</code>。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是<code>null</code>。</p>
<h3 id="1-10-Node-prototype-parentElement"><a href="#1-10-Node-prototype-parentElement" class="headerlink" title="1.10 Node.prototype.parentElement"></a>1.10 Node.prototype.parentElement</h3><p><code>parentElement</code>属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color = &apos;red&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，父元素节点的样式设定了红色。</p>
<p>由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。<code>parentElement</code>属性相当于把后两种父节点都排除了。</p>
<h3 id="1-11-Node-prototype-firstChild-lastChild"><a href="#1-11-Node-prototype-firstChild-lastChild" class="headerlink" title="1.11 Node.prototype.firstChild  , lastChild"></a>1.11 Node.prototype.firstChild  , lastChild</h3><p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;p id=&quot;p1&quot;&gt;</span><br><span class="line">//   &lt;span&gt;First span&lt;/span&gt;</span><br><span class="line">//  &lt;/p&gt;</span><br><span class="line">var p1 = document.getElementById(&apos;p1&apos;);</span><br><span class="line">p1.firstChild.nodeName // &quot;#text&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<h3 id="1-12-Node-prototype-childNodes"><a href="#1-12-Node-prototype-childNodes" class="headerlink" title="1.12 Node.prototype.childNodes"></a>1.12 Node.prototype.childNodes</h3><p><code>childNodes</code>属性返回一个类似数组的对象（<code>NodeList</code>集合），成员包括当前节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var children = document.querySelector(&apos;ul&apos;).childNodes;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>
<p>使用该属性，可以遍历某个节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var div = document.getElementById(&apos;div1&apos;);</span><br><span class="line">var children = div.childNodes;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-13-Node-prototype-isConnected"><a href="#1-13-Node-prototype-isConnected" class="headerlink" title="1.13 Node.prototype.isConnected"></a>1.13 Node.prototype.isConnected</h3><p><code>isConnected</code>属性返回一个布尔值，表示当前节点是否在文档之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var test = document.createElement(&apos;p&apos;);</span><br><span class="line">test.isConnected // false</span><br><span class="line"></span><br><span class="line">document.body.appendChild(test);</span><br><span class="line">test.isConnected // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>
<h3 id="2-1-Node-prototype-appendChild"><a href="#2-1-Node-prototype-appendChild" class="headerlink" title="2.1 Node.prototype.appendChild()"></a>2.1 Node.prototype.appendChild()</h3><p><code>appendChild()</code>方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p = document.createElement(&apos;p&apos;);</span><br><span class="line">document.body.appendChild(p);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p>
<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code>方法会将其从原来的位置，移动到尾部。</p>
<p>如果<code>appendChild()</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</p>
<h3 id="2-2-Node-prototype-hasChildNodes"><a href="#2-2-Node-prototype-hasChildNodes" class="headerlink" title="2.2 Node.prototype.hasChildNodes()"></a>2.2 Node.prototype.hasChildNodes()</h3><p><code>hasChildNodes</code>方法返回一个布尔值，表示当前节点是否有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = document.getElementById(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">if (foo.hasChildNodes()) &#123;</span><br><span class="line">  foo.removeChild(foo.childNodes[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>
<p>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>
<p><strong>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</strong></p>
<ul>
<li><code>node.hasChildNodes()</code></li>
<li><code>node.firstChild !== null</code></li>
<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ul>
<h3 id="2-3-Node-prototype-cloneNode"><a href="#2-3-Node-prototype-cloneNode" class="headerlink" title="2.3 Node.prototype.cloneNode()"></a>2.3 Node.prototype.cloneNode()</h3><p><code>cloneNode</code>方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cloneUL = document.querySelector(&apos;ul&apos;).cloneNode(true);</span><br></pre></td></tr></table></figure>
<p>该方法有一些使用注意点。</p>
<p>（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</p>
<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</p>
<p>（3）克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</p>
<h3 id="2-4-Node-prototype-insertBefore"><a href="#2-4-Node-prototype-insertBefore" class="headerlink" title="2.4 Node.prototype.insertBefore()"></a>2.4 Node.prototype.insertBefore()</h3><p><code>insertBefore</code>方法用于将某个节点插入父节点内部的指定位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var insertedNode = parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
<p><code>insertBefore</code>方法接受两个参数，第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</p>
<p>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.insertBefore(s1, s2.nextSibling);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</p>
<h3 id="2-5Node-prototype-removeChild"><a href="#2-5Node-prototype-removeChild" class="headerlink" title="2.5Node.prototype.removeChild()"></a>2.5Node.prototype.removeChild()</h3><p><code>removeChild</code>方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var divA = document.getElementById(&apos;A&apos;);</span><br><span class="line">divA.parentNode.removeChild(divA);</span><br></pre></td></tr></table></figure>
<p>上面代码移除了<code>divA</code>节点。注意，这个方法是在<code>divA</code>的父节点上调用的，不是在<code>divA</code>上调用的。</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&apos;top&apos;);</span><br><span class="line">while (element.firstChild) &#123;</span><br><span class="line">  element.removeChild(element.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-Node-prototype-replaceChild"><a href="#2-6-Node-prototype-replaceChild" class="headerlink" title="2.6 Node.prototype.replaceChild()"></a>2.6 Node.prototype.replaceChild()</h3><p><code>replaceChild</code>方法用于将一个新的节点，替换当前节点的某一个子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
<h3 id="2-7-Node-prototype-contains"><a href="#2-7-Node-prototype-contains" class="headerlink" title="2.7 Node.prototype.contains()"></a>2.7 Node.prototype.contains()</h3><p><code>contains</code>方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</p>
<ul>
<li>参数节点为当前节点。</li>
<li>参数节点为当前节点的子节点。</li>
<li>参数节点为当前节点的后代节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.contains(node)</span><br></pre></td></tr></table></figure>
<p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>
<p>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeA.contains(nodeA) // true</span><br></pre></td></tr></table></figure>
<h3 id="2-8-Node-prototype-compareDocumentPosition"><a href="#2-8-Node-prototype-compareDocumentPosition" class="headerlink" title="2.8 Node.prototype.compareDocumentPosition()"></a>2.8 Node.prototype.compareDocumentPosition()</h3><p><code>compareDocumentPosition</code>方法的用法，与<code>contains</code>方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</p>
<table>
<thead>
<tr>
<th style="text-align:left">二进制值</th>
<th style="text-align:left">十进制值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">000000</td>
<td style="text-align:left">0</td>
<td style="text-align:left">两个节点相同</td>
</tr>
<tr>
<td style="text-align:left">000001</td>
<td style="text-align:left">1</td>
<td style="text-align:left">两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td style="text-align:left">000010</td>
<td style="text-align:left">2</td>
<td style="text-align:left">参数节点在当前节点的前面</td>
</tr>
<tr>
<td style="text-align:left">000100</td>
<td style="text-align:left">4</td>
<td style="text-align:left">参数节点在当前节点的后面</td>
</tr>
<tr>
<td style="text-align:left">001000</td>
<td style="text-align:left">8</td>
<td style="text-align:left">参数节点包含当前节点</td>
</tr>
<tr>
<td style="text-align:left">010000</td>
<td style="text-align:left">16</td>
<td style="text-align:left">当前节点包含参数节点</td>
</tr>
<tr>
<td style="text-align:left">100000</td>
<td style="text-align:left">32</td>
<td style="text-align:left">浏览器内部使用</td>
</tr>
</tbody>
</table>
<h3 id="2-9-Node-prototype-isEqualNode-isSameNode"><a href="#2-9-Node-prototype-isEqualNode-isSameNode" class="headerlink" title="2.9 Node.prototype.isEqualNode()   isSameNode()"></a>2.9 Node.prototype.isEqualNode()   isSameNode()</h3><p><code>isEqualNode</code>方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</p>
<p><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</p>
<h3 id="2-10-Node-prototype-normalize"><a href="#2-10-Node-prototype-normalize" class="headerlink" title="2.10 Node.prototype.normalize()"></a>2.10 Node.prototype.normalize()</h3><p><code>normalize</code>方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</p>
<h3 id="2-11-Node-prototype-getRootNode"><a href="#2-11-Node-prototype-getRootNode" class="headerlink" title="2.11 Node.prototype.getRootNode()"></a>2.11 Node.prototype.getRootNode()</h3><p><code>getRootNode()</code>方法返回当前节点所在文档的根节点<code>document</code>，与<code>ownerDocument</code>属性的作用相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.body.firstChild.getRootNode() === document</span><br><span class="line">// true</span><br><span class="line">document.body.firstChild.getRootNode() === document.body.firstChild.ownerDocument</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>该方法可用于<code>document</code>节点自身，这一点与<code>document.ownerDocument</code>不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getRootNode() // document</span><br><span class="line">document.ownerDocument // null</span><br></pre></td></tr></table></figure>
<h2 id="NodeList接口-HTMLCollection接口"><a href="#NodeList接口-HTMLCollection接口" class="headerlink" title="NodeList接口 HTMLCollection接口"></a>NodeList接口 HTMLCollection接口</h2><p><code>NodeList</code>可以包含各种类型的节点，<code>HTMLCollection</code>只能包含 HTML 元素节点。</p>
<h3 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h3><p>通过以下方法可以得到<code>NodeList</code>实例。</p>
<ul>
<li><code>Node.childNodes</code></li>
<li><code>document.querySelectorAll()</code>等节点搜索方法</li>
</ul>
<p><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line"></span><br><span class="line">Array.isArray(children) // false</span><br><span class="line"></span><br><span class="line">children.length // 34</span><br><span class="line">children.forEach(console.log)</span><br></pre></td></tr></table></figure>
<p><strong>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line">var nodeArr = Array.prototype.slice.call(children);</span><br></pre></td></tr></table></figure>
<p>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</p>
<h3 id="1-2-NodeList-prototype-length"><a href="#1-2-NodeList-prototype-length" class="headerlink" title="1.2 NodeList.prototype.length"></a>1.2 NodeList.prototype.length</h3><p><code>length</code>属性返回 NodeList 实例包含的节点数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelectorAll(&apos;xxx&apos;).length</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure>
<h3 id="1-3-NodeList-prototype-forEach"><a href="#1-3-NodeList-prototype-forEach" class="headerlink" title="1.3 NodeList.prototype.forEach()"></a>1.3 NodeList.prototype.forEach()</h3><p><code>forEach</code>方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line">children.forEach(function f(item, i, list) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;, this);</span><br></pre></td></tr></table></figure>
<p>上面代码中，回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。<code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>
<h3 id="1-4-NodeList-prototype-item"><a href="#1-4-NodeList-prototype-item" class="headerlink" title="1.4 NodeList.prototype.item()"></a>1.4 NodeList.prototype.item()</h3><p><code>item</code>方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes.item(0)</span><br></pre></td></tr></table></figure>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.childNodes[0]</span><br></pre></td></tr></table></figure>
<h3 id="1-5-NodeList-prototype-keys-values-entries"><a href="#1-5-NodeList-prototype-keys-values-entries" class="headerlink" title="1.5 NodeList.prototype.keys(), values(),entries()"></a>1.5 NodeList.prototype.keys(), values(),entries()</h3><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var children = document.body.childNodes;</span><br><span class="line"></span><br><span class="line">for (var key of children.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">for (var value of children.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// #text</span><br><span class="line">// &lt;script&gt;</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">for (var entry of children.entries()) &#123;</span><br><span class="line">  console.log(entry);</span><br><span class="line">&#125;</span><br><span class="line">// Array [ 0, #text ]</span><br><span class="line">// Array [ 1, &lt;script&gt; ]</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<h3 id="2-1-HTMLCollection"><a href="#2-1-HTMLCollection" class="headerlink" title="2.1 HTMLCollection"></a>2.1 HTMLCollection</h3><p><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</p>
<p>返回<code>HTMLCollection</code>实例的，主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.links instanceof HTMLCollection // true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">var pic = document.getElementById(&apos;pic&apos;);</span><br><span class="line">document.images.pic === pic // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code>&lt;img&gt;</code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>
<h3 id="2-2-HTMLCollection-prototype-length"><a href="#2-2-HTMLCollection-prototype-length" class="headerlink" title="2.2 HTMLCollection.prototype.length"></a>2.2 HTMLCollection.prototype.length</h3><h3 id="2-3-HTMLCollection-prototype-item"><a href="#2-3-HTMLCollection-prototype-item" class="headerlink" title="2.3 HTMLCollection.prototype.item()"></a>2.3 HTMLCollection.prototype.item()</h3><h3 id="2-4-HTMLCollection-prototype-namedItem"><a href="#2-4-HTMLCollection-prototype-namedItem" class="headerlink" title="2.4 HTMLCollection.prototype.namedItem()"></a>2.4 HTMLCollection.prototype.namedItem()</h3><p><code>namedItem</code>方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// HTML 代码如下</span><br><span class="line">// &lt;img id=&quot;pic&quot; src=&quot;http://example.com/foo.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">var pic = document.getElementById(&apos;pic&apos;);</span><br><span class="line">document.images.namedItem(&apos;pic&apos;) === pic // true</span><br></pre></td></tr></table></figure>
<h2 id="ParentNode接口，ChildNode接口"><a href="#ParentNode接口，ChildNode接口" class="headerlink" title="ParentNode接口，ChildNode接口"></a>ParentNode接口，ChildNode接口</h2><p>如果当前节点是父节点，就会继承<code>ParentNode</code>接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承<code>ParentNode</code>接口。</p>
<h3 id="1-1ParentNode-Children"><a href="#1-1ParentNode-Children" class="headerlink" title="1.1ParentNode.Children"></a>1.1ParentNode.Children</h3><p><code>children</code>属性返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有元素子节点。该属性只读。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p>
<p>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</p>
<h3 id="1-2ParentNode-firstElementChild"><a href="#1-2ParentNode-firstElementChild" class="headerlink" title="1.2ParentNode.firstElementChild"></a>1.2ParentNode.firstElementChild</h3><p><code>firstElementChild</code>属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.firstElementChild.nodeName</span><br><span class="line">// &quot;HTML&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document</code>节点的第一个元素子节点是<code>&lt;HTML&gt;</code>。</p>
<h3 id="1-3-ParentNdoe-lastElementChild"><a href="#1-3-ParentNdoe-lastElementChild" class="headerlink" title="1.3 ParentNdoe.lastElementChild"></a>1.3 ParentNdoe.lastElementChild</h3><p><code>lastElementChild</code>属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.lastElementChild.nodeName</span><br><span class="line">// &quot;HTML&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document</code>节点的最后一个元素子节点是<code>&lt;HTML&gt;</code>（因为<code>document</code>只包含这一个元素子节点）。</p>
<h3 id="1-4-ParentNdoe-childElementCount"><a href="#1-4-ParentNdoe-childElementCount" class="headerlink" title="1.4 ParentNdoe.childElementCount"></a>1.4 ParentNdoe.childElementCount</h3><h3 id="1-5-ParentNode-append-prepend"><a href="#1-5-ParentNode-append-prepend" class="headerlink" title="1.5 ParentNode.append( ) ,prepend()"></a>1.5 ParentNode.append( ) ,prepend()</h3><p><code>append</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>
<h3 id="ChildNdoe-remove"><a href="#ChildNdoe-remove" class="headerlink" title="ChildNdoe.remove()"></a>ChildNdoe.remove()</h3><p><code>remove</code>方法用于从父节点移除当前节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure>
<p>上面代码在 DOM 里面移除了<code>el</code>节点。</p>
<h3 id="ChildNdoe-before-after"><a href="#ChildNdoe-before-after" class="headerlink" title="ChildNdoe.before(),after()"></a>ChildNdoe.before(),after()</h3><p><code>before</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var p = document.createElement(&apos;p&apos;);</span><br><span class="line">var p1 = document.createElement(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">// 插入元素节点</span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line">// 插入文本节点</span><br><span class="line">el.before(&apos;Hello&apos;);</span><br><span class="line"></span><br><span class="line">// 插入多个元素节点</span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line">// 插入元素节点和文本节点</span><br><span class="line">el.before(p, &apos;Hello&apos;);</span><br></pre></td></tr></table></figure>
<p><code>after</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</p>
<h3 id="ChildNdoe-replaceWith"><a href="#ChildNdoe-replaceWith" class="headerlink" title="ChildNdoe.replaceWith()"></a>ChildNdoe.replaceWith()</h3><p><code>replaceWith</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var span = document.createElement(&apos;span&apos;);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p>
<h2 id="Document节点"><a href="#Document节点" class="headerlink" title="Document节点"></a>Document节点</h2><h2 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h2><h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><h2 id="Text与Document-Fragment节点"><a href="#Text与Document-Fragment节点" class="headerlink" title="Text与Document Fragment节点"></a>Text与Document Fragment节点</h2><h2 id="css操作"><a href="#css操作" class="headerlink" title="css操作"></a>css操作</h2><h2 id="Mutation-Observer-API"><a href="#Mutation-Observer-API" class="headerlink" title="Mutation Observer API"></a>Mutation Observer API</h2><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="EvenTarget接口"><a href="#EvenTarget接口" class="headerlink" title="EvenTarget接口"></a>EvenTarget接口</h2><p>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p>该接口主要提供三个实例方法。</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数</li>
<li><code>removeEventListener</code>：移除事件的监听函数</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h3 id="EvenTarget-addEvenListerner"><a href="#EvenTarget-addEvenListerner" class="headerlink" title="EvenTarget.addEvenListerner()"></a>EvenTarget.addEvenListerner()</h3><p><code>EventTarget.addEventListener()</code>用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>
<p>该方法接受三个参数。</p>
<ul>
<li><code>type</code>：事件名称，大小写敏感。</li>
<li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(&apos;click&apos;, &#123;</span><br><span class="line">  handleEvent: function (event) &#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</p>
<blockquote>
<ul>
<li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li>
<li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li>
<li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li>
</ul>
</blockquote>
<p>如果希望事件监听函数只执行一次，可以打开属性配置对象的<code>once</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">  // 只执行一次的代码</span><br><span class="line">&#125;, &#123;once: true&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<h3 id="Html的on-属性"><a href="#Html的on-属性" class="headerlink" title="Html的on-属性"></a>Html的on-属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&quot;console.log(2)&quot;&gt;</span><br><span class="line">  &lt;button onClick=&quot;console.log(1)&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，即事件从子元素开始冒泡到父元素。</p>
<h3 id="元素节点的属性"><a href="#元素节点的属性" class="headerlink" title="元素节点的属性"></a>元素节点的属性</h3><p>元素节点对象的事件属性，同样可以指定监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick = function (event) &#123;</span><br><span class="line">  console.log(&apos;触发事件&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="EvenTarget-addEvenListerner-1"><a href="#EvenTarget-addEvenListerner-1" class="headerlink" title="EvenTarget.addEvenListerner()"></a>EvenTarget.addEvenListerner()</h3><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, doSomething, false);</span><br></pre></td></tr></table></figure>
<p><strong>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</strong></p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h3 id="3-事件的传播"><a href="#3-事件的传播" class="headerlink" title="3.事件的传播"></a>3.事件的传播</h3><ul>
<li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li>
<li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li>
<li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li>
</ul>
<h3 id="4-事件的代理"><a href="#4-事件的代理" class="headerlink" title="4.事件的代理"></a>4.事件的代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 事件传播到 p 元素后，就不再向下传播了</span><br><span class="line">p.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">// 事件冒泡到 p 元素后，就不再向上冒泡了</span><br><span class="line">p.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>stopPropagation</code>方法分别在捕获阶段和冒泡阶段，阻止了事件的传播。</p>
<p>但是，<code>stopPropagation</code>方法只会阻止事件的传播，不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">  // 会触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件的传播，不能取消这个事件，因此，第二个监听函数会触发。输出结果会先是1，然后是2。</p>
<p>如果想要彻底取消该事件，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(&apos;click&apos;, function (event) &#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">  // 不会被触发</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底取消这个事件，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h2 id="Event对象"><a href="#Event对象" class="headerlink" title="Event对象"></a>Event对象</h2><p>件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p>
<p><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = new Event(type, options);</span><br></pre></td></tr></table></figure>
<p><code>Event</code>构造函数接受两个参数。第一个参数<code>type</code>是字符串，表示事件的名称；第二个参数<code>options</code>是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li>
<li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li>
</ul>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h1 id="浏览器模型"><a href="#浏览器模型" class="headerlink" title="浏览器模型"></a>浏览器模型</h1><h2 id="浏览器环境概述"><a href="#浏览器环境概述" class="headerlink" title="浏览器环境概述"></a>浏览器环境概述</h2><p>网页中嵌入 JavaScript 代码，主要有三种方法。</p>
<ul>
<li><code>&lt;script&gt;</code>元素直接嵌入代码。</li>
<li><code>&lt;script&gt;</code>标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<h3 id="1-script元素嵌入代码"><a href="#1-script元素嵌入代码" class="headerlink" title="1 script元素嵌入代码"></a>1 script元素嵌入代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var x = 1 + 5;</span><br><span class="line">  console.log(x);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<script>标签有一个type属性，用来指定脚本类型。对 JavaScript 脚本来说，type属性可以设为两种值。

- `text/javascript`：这是默认值，也是历史上一贯设定的值。如果你省略`type`属性，默认就是这个值。对于老式浏览器，设为这个值比较好。
- `application/javascript`：对于较新的浏览器，建议设为这个值。

### 2 script元素加载外部脚本

<script>标签也可以指定加载外部的脚本文件。
<script src="https://www.example.com/script.js"></script>


<p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>
<script charset="utf-8" src="https://www.example.com/script.js"></script>


<p>所加载的脚本必须是纯的 JavaScript 代码，不能有HTML代码和<script>标签。</p>
<p>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的console.log语句直接被忽略。</p>
<script charset="utf-8" src="example.js">
  console.log('Hello World!');
</script>


</p><p>为了防止攻击者篡改外部脚本，script标签允许设置一个integrity属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>
<p><script src="/assets/application.js" integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs="><br></script><br>上面代码中，script标签有一个integrity属性，指定了外部脚本/assets/application.js的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>
<h3 id="3-事件属性"><a href="#3-事件属性" class="headerlink" title="3 事件属性"></a>3 事件属性</h3><p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myBtn&quot; onclick=&quot;console.log(this.id)&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>
<h3 id="4-URL协议"><a href="#4-URL协议" class="headerlink" title="4.URL协议"></a>4.URL协议</h3><p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:console.log(&apos;Hello&apos;)&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log(&#39;Hello&#39;)</code>放入地址栏，按回车键也会执行这段代码。</p>
<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: new Date().toLocaleTimeString();&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: console.log(new Date().toLocaleTimeString())&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: void new Date().toLocaleTimeString();&quot;&gt;点击&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/23/css布局/" rel="next" title="css布局">
                <i class="fa fa-chevron-left"></i> css布局
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">cjy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本语法"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标志符"><span class="nav-number">1.1.</span> <span class="nav-text">标志符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量提升"><span class="nav-number">1.2.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件语句"><span class="nav-number">1.3.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标签-label"><span class="nav-number">1.4.</span> <span class="nav-text">标签(label)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof运算符"><span class="nav-number">2.1.</span> <span class="nav-text">typeof运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-undefined-和布尔值"><span class="nav-number">2.2.</span> <span class="nav-text">null undefined 和布尔值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值"><span class="nav-number">2.3.</span> <span class="nav-text">数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值精度"><span class="nav-number">2.4.</span> <span class="nav-text">数值精度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isNaN"><span class="nav-number">2.5.</span> <span class="nav-text">isNaN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">2.6.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的引用"><span class="nav-number">2.6.1.</span> <span class="nav-text">对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的继承"><span class="nav-number">2.6.2.</span> <span class="nav-text">对象的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的继承"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">构造函数的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多重继承"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块"><span class="nav-number">2.6.2.4.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#封装私有变量：立即执行函数的写法"><span class="nav-number">2.6.2.4.1.</span> <span class="nav-text">封装私有变量：立即执行函数的写法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#放大模式"><span class="nav-number">2.6.2.5.</span> <span class="nav-text">放大模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object对象的相关方法"><span class="nav-number">2.6.3.</span> <span class="nav-text">Object对象的相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">2.6.4.</span> <span class="nav-text">Object.create()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-prototype-isPrototypeOf"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">Object.prototype.isPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object-prototype-proto"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">object.prototype.proto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取原型对象方法的比较"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">获取原型对象方法的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyName"><span class="nav-number">2.6.4.4.</span> <span class="nav-text">Object.getOwnPropertyName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-prototpye-hasOwnProperty"><span class="nav-number">2.6.4.5.</span> <span class="nav-text">Object.prototpye.hasOwnProperty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-与-for-in"><span class="nav-number">2.6.4.6.</span> <span class="nav-text">in 与 for ..in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的拷贝"><span class="nav-number">2.6.4.7.</span> <span class="nav-text">对象的拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格模式"><span class="nav-number">2.6.5.</span> <span class="nav-text">严格模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启用方法"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">启用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显示报错"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">显示报错</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只读属性不可写"><span class="nav-number">2.6.5.2.1.</span> <span class="nav-text">只读属性不可写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。"><span class="nav-number">2.6.5.2.2.</span> <span class="nav-text">严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#禁止扩展的对象不可扩展"><span class="nav-number">2.6.5.2.3.</span> <span class="nav-text">禁止扩展的对象不可扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eval、arguments-不可用作标识名"><span class="nav-number">2.6.5.2.4.</span> <span class="nav-text">eval、arguments 不可用作标识名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数不能有重名的参数"><span class="nav-number">2.6.5.2.5.</span> <span class="nav-text">函数不能有重名的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#禁止八进制的前缀0表示法"><span class="nav-number">2.6.5.2.6.</span> <span class="nav-text">禁止八进制的前缀0表示法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增强的安全措施"><span class="nav-number">2.6.6.</span> <span class="nav-text">增强的安全措施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态绑定"><span class="nav-number">2.6.7.</span> <span class="nav-text">静态绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向ES6过渡"><span class="nav-number">2.6.8.</span> <span class="nav-text">向ES6过渡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非函数代码块不得声明函数"><span class="nav-number">2.6.8.1.</span> <span class="nav-text">非函数代码块不得声明函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保留字"><span class="nav-number">2.6.8.2.</span> <span class="nav-text">保留字</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步操作"><span class="nav-number">3.</span> <span class="nav-text">异步操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步任务和异步任务"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">同步任务和异步任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步操作的模式"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">异步操作的模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1回调函数"><span class="nav-number">3.0.0.2.1.</span> <span class="nav-text">4.1回调函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2事件监听"><span class="nav-number">3.0.0.2.2.</span> <span class="nav-text">4.2事件监听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-发布-订阅"><span class="nav-number">3.0.0.2.3.</span> <span class="nav-text">4.3 发布/订阅</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-异步操作的流程控制"><span class="nav-number">3.0.1.</span> <span class="nav-text">5.异步操作的流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise对象"><span class="nav-number">3.0.2.</span> <span class="nav-text">Promise对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise对象的状态"><span class="nav-number">3.0.2.1.</span> <span class="nav-text">Promise对象的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise构造函数"><span class="nav-number">3.0.2.2.</span> <span class="nav-text">Promise构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-prototype-then"><span class="nav-number">3.0.2.3.</span> <span class="nav-text">Promise.prototype.then</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微任务"><span class="nav-number">3.0.2.4.</span> <span class="nav-text">微任务</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#DOM"><span class="nav-number">4.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Node接口"><span class="nav-number">4.1.</span> <span class="nav-text">Node接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Node-prototype-nodeType"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.1 Node.prototype.nodeType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Node-prototype-nodeName"><span class="nav-number">4.1.2.</span> <span class="nav-text">1.2 Node.prototype.nodeName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3Node-prototype-nodeValue"><span class="nav-number">4.1.3.</span> <span class="nav-text">1.3Node.prototype.nodeValue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Node-prototype-textContent"><span class="nav-number">4.1.4.</span> <span class="nav-text">1.4 Node.prototype.textContent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Node-prototype-baseURI"><span class="nav-number">4.1.5.</span> <span class="nav-text">1.5 Node.prototype.baseURI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Node-prototype-ownerDocument"><span class="nav-number">4.1.6.</span> <span class="nav-text">1.6 Node.prototype.ownerDocument</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Node-prototype-nextSibling"><span class="nav-number">4.1.7.</span> <span class="nav-text">1.7 Node.prototype.nextSibling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-Node-prototype-previousSibling"><span class="nav-number">4.1.8.</span> <span class="nav-text">1.8 Node.prototype.previousSibling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-Node-prototype-parentNode"><span class="nav-number">4.1.9.</span> <span class="nav-text">1.9 Node.prototype.parentNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-Node-prototype-parentElement"><span class="nav-number">4.1.10.</span> <span class="nav-text">1.10 Node.prototype.parentElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-Node-prototype-firstChild-lastChild"><span class="nav-number">4.1.11.</span> <span class="nav-text">1.11 Node.prototype.firstChild  , lastChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-Node-prototype-childNodes"><span class="nav-number">4.1.12.</span> <span class="nav-text">1.12 Node.prototype.childNodes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-Node-prototype-isConnected"><span class="nav-number">4.1.13.</span> <span class="nav-text">1.13 Node.prototype.isConnected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Node-prototype-appendChild"><span class="nav-number">4.1.14.</span> <span class="nav-text">2.1 Node.prototype.appendChild()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Node-prototype-hasChildNodes"><span class="nav-number">4.1.15.</span> <span class="nav-text">2.2 Node.prototype.hasChildNodes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Node-prototype-cloneNode"><span class="nav-number">4.1.16.</span> <span class="nav-text">2.3 Node.prototype.cloneNode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Node-prototype-insertBefore"><span class="nav-number">4.1.17.</span> <span class="nav-text">2.4 Node.prototype.insertBefore()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5Node-prototype-removeChild"><span class="nav-number">4.1.18.</span> <span class="nav-text">2.5Node.prototype.removeChild()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Node-prototype-replaceChild"><span class="nav-number">4.1.19.</span> <span class="nav-text">2.6 Node.prototype.replaceChild()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Node-prototype-contains"><span class="nav-number">4.1.20.</span> <span class="nav-text">2.7 Node.prototype.contains()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-Node-prototype-compareDocumentPosition"><span class="nav-number">4.1.21.</span> <span class="nav-text">2.8 Node.prototype.compareDocumentPosition()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-Node-prototype-isEqualNode-isSameNode"><span class="nav-number">4.1.22.</span> <span class="nav-text">2.9 Node.prototype.isEqualNode()   isSameNode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-Node-prototype-normalize"><span class="nav-number">4.1.23.</span> <span class="nav-text">2.10 Node.prototype.normalize()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-Node-prototype-getRootNode"><span class="nav-number">4.1.24.</span> <span class="nav-text">2.11 Node.prototype.getRootNode()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeList接口-HTMLCollection接口"><span class="nav-number">4.2.</span> <span class="nav-text">NodeList接口 HTMLCollection接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeList接口"><span class="nav-number">4.2.1.</span> <span class="nav-text">NodeList接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-NodeList-prototype-length"><span class="nav-number">4.2.2.</span> <span class="nav-text">1.2 NodeList.prototype.length</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-NodeList-prototype-forEach"><span class="nav-number">4.2.3.</span> <span class="nav-text">1.3 NodeList.prototype.forEach()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-NodeList-prototype-item"><span class="nav-number">4.2.4.</span> <span class="nav-text">1.4 NodeList.prototype.item()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-NodeList-prototype-keys-values-entries"><span class="nav-number">4.2.5.</span> <span class="nav-text">1.5 NodeList.prototype.keys(), values(),entries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-HTMLCollection"><span class="nav-number">4.2.6.</span> <span class="nav-text">2.1 HTMLCollection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-HTMLCollection-prototype-length"><span class="nav-number">4.2.7.</span> <span class="nav-text">2.2 HTMLCollection.prototype.length</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-HTMLCollection-prototype-item"><span class="nav-number">4.2.8.</span> <span class="nav-text">2.3 HTMLCollection.prototype.item()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-HTMLCollection-prototype-namedItem"><span class="nav-number">4.2.9.</span> <span class="nav-text">2.4 HTMLCollection.prototype.namedItem()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ParentNode接口，ChildNode接口"><span class="nav-number">4.3.</span> <span class="nav-text">ParentNode接口，ChildNode接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1ParentNode-Children"><span class="nav-number">4.3.1.</span> <span class="nav-text">1.1ParentNode.Children</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2ParentNode-firstElementChild"><span class="nav-number">4.3.2.</span> <span class="nav-text">1.2ParentNode.firstElementChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-ParentNdoe-lastElementChild"><span class="nav-number">4.3.3.</span> <span class="nav-text">1.3 ParentNdoe.lastElementChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-ParentNdoe-childElementCount"><span class="nav-number">4.3.4.</span> <span class="nav-text">1.4 ParentNdoe.childElementCount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-ParentNode-append-prepend"><span class="nav-number">4.3.5.</span> <span class="nav-text">1.5 ParentNode.append( ) ,prepend()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNdoe-remove"><span class="nav-number">4.3.6.</span> <span class="nav-text">ChildNdoe.remove()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNdoe-before-after"><span class="nav-number">4.3.7.</span> <span class="nav-text">ChildNdoe.before(),after()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNdoe-replaceWith"><span class="nav-number">4.3.8.</span> <span class="nav-text">ChildNdoe.replaceWith()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Document节点"><span class="nav-number">4.4.</span> <span class="nav-text">Document节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Element节点"><span class="nav-number">4.5.</span> <span class="nav-text">Element节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性的操作"><span class="nav-number">4.6.</span> <span class="nav-text">属性的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Text与Document-Fragment节点"><span class="nav-number">4.7.</span> <span class="nav-text">Text与Document Fragment节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css操作"><span class="nav-number">4.8.</span> <span class="nav-text">css操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutation-Observer-API"><span class="nav-number">4.9.</span> <span class="nav-text">Mutation Observer API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件"><span class="nav-number">5.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EvenTarget接口"><span class="nav-number">5.1.</span> <span class="nav-text">EvenTarget接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EvenTarget-addEvenListerner"><span class="nav-number">5.1.1.</span> <span class="nav-text">EvenTarget.addEvenListerner()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件模型"><span class="nav-number">5.2.</span> <span class="nav-text">事件模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Html的on-属性"><span class="nav-number">5.2.1.</span> <span class="nav-text">Html的on-属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素节点的属性"><span class="nav-number">5.2.2.</span> <span class="nav-text">元素节点的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EvenTarget-addEvenListerner-1"><span class="nav-number">5.2.3.</span> <span class="nav-text">EvenTarget.addEvenListerner()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-事件的传播"><span class="nav-number">5.2.4.</span> <span class="nav-text">3.事件的传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-事件的代理"><span class="nav-number">5.2.5.</span> <span class="nav-text">4.事件的代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event对象"><span class="nav-number">5.3.</span> <span class="nav-text">Event对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">5.3.1.</span> <span class="nav-text"> </span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器模型"><span class="nav-number">6.</span> <span class="nav-text">浏览器模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器环境概述"><span class="nav-number">6.1.</span> <span class="nav-text">浏览器环境概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-script元素嵌入代码"><span class="nav-number">6.1.1.</span> <span class="nav-text">1 script元素嵌入代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-事件属性"><span class="nav-number">6.1.2.</span> <span class="nav-text">3 事件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-URL协议"><span class="nav-number">6.1.3.</span> <span class="nav-text">4.URL协议</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cjy</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
